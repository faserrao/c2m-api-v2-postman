#!/bin/bash
# =============================================================================
# Pipeline Output Validation Tests
# =============================================================================
# Purpose: Validate the outputs of a completed pipeline run
# Author: Generated by Claude
# Date: September 27, 2025
# =============================================================================

set -uo pipefail  # Removed -e to collect all failures before exiting

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Results tracking
VALIDATIONS_PASSED=0
VALIDATIONS_FAILED=0

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

log_check() {
    echo -e "${BLUE}[CHECK]${NC} $1"
}

log_pass() {
    echo -e "${GREEN}[PASS]${NC} $1"
    ((VALIDATIONS_PASSED++))
}

log_fail() {
    echo -e "${RED}[FAIL]${NC} $1"
    ((VALIDATIONS_FAILED++))
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

validate_openapi_spec() {
    log_check "Validating OpenAPI specifications..."
    
    # Check base spec
    if [ -f "openapi/c2mapiv2-openapi-spec-base.yaml" ]; then
        log_pass "Base OpenAPI spec exists"
        
        # Check structure
        local title=$(yq eval '.info.title' openapi/c2mapiv2-openapi-spec-base.yaml 2>/dev/null)
        if [ -n "$title" ]; then
            log_info "  Base spec title: $title"
        fi
        
        # Count paths
        local path_count=$(yq eval '.paths | keys | length' openapi/c2mapiv2-openapi-spec-base.yaml 2>/dev/null || echo "0")
        log_info "  Base spec has $path_count paths"
    else
        log_fail "Base OpenAPI spec missing"
    fi
    
    # Check final spec
    if [ -f "openapi/c2mapiv2-openapi-spec-final.yaml" ]; then
        log_pass "Final OpenAPI spec exists"
        
        # Check if auth endpoints were merged
        if grep -q "/auth/tokens" openapi/c2mapiv2-openapi-spec-final.yaml; then
            log_pass "Auth endpoints present in final spec"
        else
            log_fail "Auth endpoints missing from final spec"
        fi
        
        # Check title (should not be "Auth Overlay")
        local final_title=$(yq eval '.info.title' openapi/c2mapiv2-openapi-spec-final.yaml 2>/dev/null)
        log_info "  Final spec title: $final_title"
        
        # Count total paths
        local final_path_count=$(yq eval '.paths | keys | length' openapi/c2mapiv2-openapi-spec-final.yaml 2>/dev/null || echo "0")
        log_info "  Final spec has $final_path_count paths"
    else
        log_fail "Final OpenAPI spec missing"
    fi
    
    # Check examples spec
    if [ -f "openapi/c2mapiv2-openapi-spec-final-with-examples.yaml" ]; then
        log_pass "OpenAPI spec with examples exists"

        # Check if SDK code samples (x-codeSamples) were added
        local has_code_samples=$(yq eval '[.. | select(has("x-codeSamples"))] | length' openapi/c2mapiv2-openapi-spec-final-with-examples.yaml 2>/dev/null || echo "0")
        if [ "$has_code_samples" -gt "0" ]; then
            log_pass "SDK code samples found in spec ($has_code_samples endpoints)"
        else
            log_info "No SDK code samples found (x-codeSamples)"
        fi
    else
        log_info "OpenAPI spec with examples not found (may be optional)"
    fi
}

validate_postman_collections() {
    log_check "Validating Postman collections..."
    
    # Check linked collection
    if [ -f "postman/generated/c2mapiv2-linked-collection-flat.json" ]; then
        log_pass "Linked collection exists"
        
        # Validate structure
        local info_name=$(jq -r '.info.name' postman/generated/c2mapiv2-linked-collection-flat.json 2>/dev/null)
        if [ -n "$info_name" ] && [ "$info_name" != "null" ]; then
            log_pass "Linked collection has valid info block"
            log_info "  Collection name: $info_name"
        else
            log_fail "Linked collection missing info block"
        fi
        
        # Check if flattened
        local nested_count=$(jq '[.item[] | select(has("item"))] | length' postman/generated/c2mapiv2-linked-collection-flat.json 2>/dev/null || echo "-1")
        if [ "$nested_count" = "0" ]; then
            log_pass "Linked collection is properly flattened"
        else
            log_fail "Linked collection has nested folders (count: $nested_count)"
        fi
        
        # Check item count
        local item_count=$(jq '.item | length' postman/generated/c2mapiv2-linked-collection-flat.json 2>/dev/null || echo "0")
        log_info "  Collection has $item_count items"
        
        # Check if pre-request script was added
        local has_prerequest=$(jq '.event[] | select(.listen == "prerequest") | length' postman/generated/c2mapiv2-linked-collection-flat.json 2>/dev/null || echo "0")
        if [ "$has_prerequest" -gt "0" ]; then
            log_pass "Pre-request script found in linked collection"
        else
            log_fail "Pre-request script missing from linked collection"
        fi
        
        # Check request naming format
        local first_request_name=$(jq -r '.item[0].name' postman/generated/c2mapiv2-linked-collection-flat.json 2>/dev/null)
        if [[ "$first_request_name" =~ ^[A-Z]+\ / ]]; then
            log_pass "Request naming follows 'METHOD /path' format"
            log_info "  Example: $first_request_name"
        else
            log_fail "Request naming doesn't follow expected format"
        fi
    else
        log_fail "Linked collection not found"
    fi
    
    # Check test collection
    if [ -f "postman/generated/c2mapiv2-test-collection-fixed.json" ]; then
        log_pass "Test collection exists"
        
        # Check if tests were added (check all nesting levels with recursive descent)
        local test_count=$(jq '[.. | objects | .event? // empty | .[]? | select(.listen == "test") | .script.exec[] | select(contains("pm.test"))] | length' postman/generated/c2mapiv2-test-collection-fixed.json 2>/dev/null || echo "0")
        if [ "$test_count" -gt "0" ]; then
            log_pass "Test scripts found in collection ($test_count test assertions)"
        else
            log_fail "No test scripts found in test collection"
        fi
        
        # Check if examples were added (check all nesting levels with recursive descent)
        local example_count=$(jq '[.. | .request?.body?.raw? | select(. != null and . != "")] | length' postman/generated/c2mapiv2-test-collection-fixed.json 2>/dev/null || echo "0")
        if [ "$example_count" -gt "0" ]; then
            log_pass "Request examples found ($example_count requests with body)"
        else
            log_info "No request examples found (may be GET requests)"
        fi
    else
        log_fail "Test collection not found"
    fi
}

validate_postman_artifacts() {
    log_check "Validating Postman artifacts..."
    
    # Check UID files
    local uid_files=(
        "postman/postman_api_uid.txt"
        "postman/postman_linked_collection_uid.txt"
        "postman/test_collection_uid.txt"
        "postman/postman_spec_uid.txt"
    )
    
    for uid_file in "${uid_files[@]}"; do
        if [ -f "$uid_file" ]; then
            local uid=$(cat "$uid_file" 2>/dev/null | tr -d '\n')
            if [ -n "$uid" ]; then
                log_pass "$(basename $uid_file) contains UID: ${uid:0:20}..."
            else
                log_fail "$(basename $uid_file) is empty"
            fi
        else
            log_info "$(basename $uid_file) not found (may be optional)"
        fi
    done
    
    # Check mock server files
    if [ -f "postman/postman_mock_uid.txt" ]; then
        log_pass "Mock server UID file exists"
    else
        log_info "Mock server UID not found (mock may not be created)"
    fi
    
    # Check environment files
    if [ -f "postman/mock-env.json" ]; then
        log_pass "Mock environment file exists"
        
        # Validate environment structure
        local env_name=$(jq -r '.name' postman/mock-env.json 2>/dev/null)
        if [ -n "$env_name" ] && [ "$env_name" != "null" ]; then
            log_info "  Environment name: $env_name"
        fi
        
        # Check for auth variables
        local has_client_id=$(jq '.values[] | select(.key == "clientId") | length' postman/mock-env.json 2>/dev/null || echo "0")
        local has_client_secret=$(jq '.values[] | select(.key == "clientSecret") | length' postman/mock-env.json 2>/dev/null || echo "0")

        if [ "$has_client_id" -gt "0" ] && [ "$has_client_secret" -gt "0" ]; then
            log_pass "Auth credentials found in environment"
        else
            # In CI/CD, credentials come from GitHub Secrets and are uploaded to Postman
            # Local file may be sanitized after upload - this is acceptable
            local build_type="${BUILD_TYPE:-local}"
            if [ "$build_type" = "github" ]; then
                log_info "Auth credentials not in local file (expected in CI/CD - credentials uploaded to Postman)"
            else
                log_fail "Auth credentials missing from environment"
            fi
        fi
    else
        log_info "Mock environment file not found"
    fi
}

validate_documentation() {
    log_check "Validating documentation..."

    # Check Redoc output (generated as docs/index.html by docs-build target)
    if [ -f "docs/index.html" ]; then
        log_pass "Redoc documentation exists"

        # Check file size (should be substantial)
        local file_size=$(stat -f%z "docs/index.html" 2>/dev/null || stat -c%s "docs/index.html" 2>/dev/null || echo "0")
        if [ "$file_size" -gt 100000 ]; then
            log_pass "Documentation file size OK ($(($file_size / 1024))KB)"
        else
            log_fail "Documentation file seems too small ($(($file_size / 1024))KB)"
        fi
    else
        log_fail "Redoc documentation not found (expected docs/index.html)"
    fi
    
    # Check bundled spec
    if [ -f "openapi/bundled.yaml" ]; then
        log_pass "Bundled OpenAPI spec exists"
    else
        log_info "Bundled OpenAPI spec not found (optional)"
    fi
}

validate_test_results() {
    log_check "Validating test results..."
    
    # Check Newman report
    if [ -f "postman/newman-report.html" ]; then
        log_pass "Newman HTML report exists"
    else
        log_info "Newman HTML report not found (tests may not have run)"
    fi
    
    # Check Prism log
    if [ -f "postman/prism-mock.log" ]; then
        log_pass "Prism mock server log exists"
        
        # Check if Prism started successfully
        if grep -q "Prism is listening" postman/prism-mock.log; then
            log_pass "Prism mock server started successfully"
        else
            log_info "Prism startup not confirmed in log"
        fi
    else
        log_info "Prism log not found (local mock may not have run)"
    fi
}

# =============================================================================
# SUMMARY REPORT
# =============================================================================

generate_summary() {
    echo ""
    echo -e "${BLUE}===================================================================${NC}"
    echo -e "${BLUE}VALIDATION SUMMARY${NC}"
    echo -e "${BLUE}===================================================================${NC}"
    
    local total=$((VALIDATIONS_PASSED + VALIDATIONS_FAILED))
    echo "Total validations: $total"
    echo -e "Passed: ${GREEN}$VALIDATIONS_PASSED${NC}"
    echo -e "Failed: ${RED}$VALIDATIONS_FAILED${NC}"
    
    echo ""
    if [ $VALIDATIONS_FAILED -eq 0 ]; then
        echo -e "${GREEN}‚úÖ All pipeline outputs validated successfully!${NC}"
        echo -e "${GREEN}   The pipeline completed all expected steps.${NC}"
        return 0
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Some validations failed${NC}"
        echo -e "${YELLOW}   Review the failures above for details.${NC}"
        return 1
    fi
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    echo "üìä C2M API Pipeline Output Validation"
    echo "üìÖ $(date)"
    echo ""
    
    validate_openapi_spec
    echo ""
    
    validate_postman_collections
    echo ""
    
    validate_postman_artifacts
    echo ""
    
    validate_documentation
    echo ""
    
    validate_test_results
    
    generate_summary
}

# Run validation
main